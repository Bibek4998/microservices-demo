name: CI — build images, push to Docker Hub & deploy to K8s

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_NAMESPACE: bibek49
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build:
    name: Build & push images
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.set-images.outputs.images }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Determine services to build
        id: find-services
        run: |
          # Prefer services.txt (format: name::context::Dockerfile) if present.
          services_file="services.txt"
          echo "GITHUB_SHA=${GITHUB_SHA}"
          services=""
          if [ -f "$services_file" ]; then
            echo "Found services.txt — parsing entries"
            while IFS= read -r line || [ -n "$line" ]; do
              # parse with awk to support '::' multi-character separator
              name=$(awk -F'::' '{print $1}' <<< "$line")
              context=$(awk -F'::' '{print $2}' <<< "$line")
              dockerfile=$(awk -F'::' '{print $3}' <<< "$line")
              # normalise fields
              context=${context:-.}
              dockerfile=${dockerfile:-Dockerfile}
              services="${services}${name}::${context}::${dockerfile}\n"
            done < "$services_file"
          else
            echo "No services.txt — discovering Dockerfiles under the repo"
            # Discover Dockerfiles and use the containing directory name as image name.
            # Skip top-level Dockerfiles used for tooling unless they are service-specific.
            while IFS= read -r df; do
              dir=$(dirname "$df")
              name=$(basename "$dir")
              # Use Dockerfile name if not standard
              dockerfile=$(basename "$df")
              services="${services}${name}::${dir}::${dockerfile}\n"
            done < <(git ls-files --full-name '**/Dockerfile' || true)
          fi
          # output as a file for the next step
          printf "%b" "$services" > discovered_services.txt
          echo "Discovered services (first 200 chars):"
          head -c 200 discovered_services.txt || true
          echo "::set-output name=services::$(wc -l < discovered_services.txt || true)"

      - name: Build & push images (multi-arch)
        id: build-and-push
        run: |
          set -euo pipefail
          images_out=""
          if [ ! -f discovered_services.txt ]; then
            echo "No services discovered — exiting"
            exit 1
          fi

          while IFS= read -r entry || [ -n "$entry" ]; do
            # entry = name::context::dockerfile
            name=$(awk -F'::' '{print $1}' <<< "$entry")
            context=$(awk -F'::' '{print $2}' <<< "$entry")
            dockerfile=$(awk -F'::' '{print $3}' <<< "$entry")
            # normalize defaults
            context=${context:-.}
            dockerfile=${dockerfile:-Dockerfile}

            image="${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${name}:${IMAGE_TAG}"
            image_latest="${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${name}:latest"

            echo "==== Building ${image} (context=${context}, dockerfile=${dockerfile}) ===="
            # Build and push multi-arch images
            docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --build-arg GITHUB_SHA=${GITHUB_SHA} \
              -t "${image}" \
              -t "${image_latest}" \
              -f "${context}/${dockerfile}" \
              "${context}" \
              --push

            images_out="${images_out}${name}=${image},"
          done < discovered_services.txt

          # Trim trailing comma
          images_out="${images_out%,}"
          echo "Pushed images: ${images_out}"
          echo "::set-output name=images::${images_out}"
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_NAMESPACE: ${{ env.DOCKER_NAMESPACE }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

      - name: Set outputs
        id: set-images
        run: |
          echo "images=${{ steps.build-and-push.outputs.images }}" > tmp.out
          echo "::set-output name=images::${{ steps.build-and-push.outputs.images }}"

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Restore kubeconfig from secret
        id: kubeconfig
        run: |
          # Expect a secret named KUBE_CONFIG_DATA which contains base64-encoded kubeconfig
          if [ -z "${{ secrets.KUBE_CONFIG_DATA }}" ]; then
            echo "ERROR: secrets.KUBE_CONFIG_DATA is not set. Provide your kubeconfig base64 encoded."
            exit 1
          fi
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 --decode > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "kubeconfig written to $HOME/.kube/config"

      - name: Prepare manifests with new images
        id: replace-and-apply
        run: |
          set -euo pipefail
          # copy manifests to a temp dir and replace known upstream repo prefix with our namespace
          TMPDIR=$(mktemp -d)
          echo "temp manifests dir: $TMPDIR"
          # prefer deploy/kubernetes/manifests/ if exists, otherwise use complete-demo.yaml or deploy/kubernetes
          if [ -d deploy/kubernetes/manifests ]; then
            cp -r deploy/kubernetes/manifests "$TMPDIR"/manifests
            MANIFEST_PATH="$TMPDIR/manifests"
          elif [ -f deploy/kubernetes/complete-demo.yaml ]; then
            mkdir -p "$TMPDIR"/manifests
            cp deploy/kubernetes/complete-demo.yaml "$TMPDIR"/manifests/
            MANIFEST_PATH="$TMPDIR/manifests"
          else
            # fallback to entire deploy/kubernetes
            cp -r deploy/kubernetes "$TMPDIR"/manifests
            MANIFEST_PATH="$TMPDIR/manifests"
          fi

          echo "Replacing image prefixes in manifests..."
          # replace well-known upstream prefix (weaveworksdemos/) with your dockerhub namespace
          find "$MANIFEST_PATH" -type f -name '*.yaml' -o -name '*.yml' | while read -r mf; do
            # use sed substitution (make backup then move)
            sed -i.bak "s@weaveworksdemos/@${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/@g" "$mf" || true
            # remove backup
            rm -f "${mf}.bak" || true
          done

          echo "Applying manifests to cluster..."
          kubectl apply -R -f "$MANIFEST_PATH"

          # If you want to explicitly update deployments image-by-image using the build outputs:
          images="${{ needs.build.outputs.images }}"
          echo "Build outputs: $images"
          # images format: name=url,name2=url2
          IFS=',' read -ra pairs <<< "$images" || true
          for p in "${pairs[@]}"; do
            svc=$(cut -d'=' -f1 <<< "$p")
            image=$(cut -d'=' -f2 <<< "$p")
            # try updating deployments matching the service name (best-effort)
            if kubectl get deploy -A -o name | grep -q "$svc"; then
              echo "Updating deployments matching: $svc -> $image"
              # update all deployments that contain svc in name
              kubectl get deploy -A -o name | grep "$svc" | while read -r d; do
                # get namespace and deployment name from the resource string "deployment/namespace/name" or "deployment/name"
                # kubectl outputs "deployment.apps/<name>" or "deployment/<name>" — use kubectl set image with -n if namespace known
                # Best-effort: try without namespace
                depname=$(basename "$d")
                kubectl set image deployment/"$depname" "$svc"="$image" --ignore-not-found || true
              done
            else
              echo "No matching deployment found for service: $svc (skipping explicit set-image)"
            fi
          done
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_NAMESPACE: ${{ env.DOCKER_NAMESPACE }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
