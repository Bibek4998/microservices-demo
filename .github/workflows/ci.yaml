name: CI / Build, Push & Deploy

# Run on push to main and on PRs targeting main
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_NAMESPACE: bibek49
  IMAGE_TAG: ${{ github.sha }}

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    name: Build images and push to registry
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU (for multi-platform builds, optional)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Discover services and images to build
        id: discover
        run: |
          # Candidate service names (common services in this repo)
          SERVICES="front-end edge-router catalogue carts orders shipping queue-master payment user user-sim graphs healthcheck openapi"
          MANIFEST_DIRS="deploy/kubernetes deploy/kubernetes/manifests deploy/kubernetes/manifests-*"
          # Build list of images to replace (we look for weaveworksdemos references in manifests)
          declare -A IMAGES
          # 1) If a service folder contains a Dockerfile, add it
          for s in $SERVICES; do
            if [ -f "$s/Dockerfile" ] || [ -f "$s/docker/Dockerfile" ] || [ -f "deploy/$s/Dockerfile" ]; then
              IMAGES[$s]=1
            fi
          done
          # 2) Also scan kubernetes manifests for weaveworksdemos/<service> references
          for d in $MANIFEST_DIRS; do
            if [ -d "$d" ]; then
              while grep -Eor "weaveworksdemos/[a-zA-Z0-9_.-]+" "$d" 2>/dev/null | sed 's|weaveworksdemos/||' | sort -u | while read -r svc; do
                [ -n "$svc" ] && IMAGES[$svc]=1
              done
            fi
          done
          # Output a newline-separated list
          for k in "${!IMAGES[@]}"; do echo "$k"; done | sort > services-to-build.txt
          echo "services=$(cat services-to-build.txt | tr '\n' ' ')" >> $GITHUB_OUTPUT
          echo "Found services: $(cat services-to-build.txt | tr '\n' ' ')" 
      - name: Show discovered services
        run: |
          echo "Services to build: ${{ steps.discover.outputs.services }}"

      - name: Build & push images (loop)
        run: |
          set -euo pipefail
          if [ -z "${{ steps.discover.outputs.services }}" ]; then
            echo "No services discovered to build. Exiting."
            exit 0
          fi

          IFS=' ' read -r -a SERVICES <<< "${{ steps.discover.outputs.services }}"

          for svc in "${SERVICES[@]}"; do
            # Determine Dockerfile location heuristically
            DOCKERFILE=""
            if [ -f "$svc/Dockerfile" ]; then
              DOCKERFILE="$svc/Dockerfile"
              CONTEXT="$svc"
            elif [ -f "$svc/docker/Dockerfile" ]; then
              DOCKERFILE="$svc/docker/Dockerfile"
              CONTEXT="$svc/docker"
            elif [ -f "deploy/kubernetes/$svc/Dockerfile" ]; then
              DOCKERFILE="deploy/kubernetes/$svc/Dockerfile"
              CONTEXT="deploy/kubernetes/$svc"
            elif [ -f "graphs/Dockerfile" ] && [ "$svc" = "graphs" ]; then
              DOCKERFILE="graphs/Dockerfile"
              CONTEXT="graphs"
            elif [ -f "healthcheck/Dockerfile" ] && [ "$svc" = "healthcheck" ]; then
              DOCKERFILE="healthcheck/Dockerfile"
              CONTEXT="healthcheck"
            elif [ -f "openapi/Dockerfile" ] && [ "$svc" = "openapi" ]; then
              DOCKERFILE="openapi/Dockerfile"
              CONTEXT="openapi"
            else
              # If no Dockerfile, skip building (image probably external DB or official image)
              echo "Skipping ${svc}: no Dockerfile found in expected locations."
              continue
            fi

            IMAGE="${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/${svc}:${{ env.IMAGE_TAG }}"
            echo "Building ${IMAGE} from ${DOCKERFILE} (context ${CONTEXT})"

            # Use buildx build + push
            docker buildx build --platform linux/amd64 --file "${DOCKERFILE}" --tag "${IMAGE}" --push "${CONTEXT}"
            echo "Built & pushed ${IMAGE}"
          done

  deploy:
    name: Deploy to Kubernetes cluster
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Prepare kubeconfig
        # Provide your kubeconfig base64 as secret KUBE_CONFIG_DATA (base64 encoded)
        env:
          KUBECONFIG_FILE: ${{ runner.temp }}/kubeconfig
        run: |
          if [ -z "${{ secrets.KUBE_CONFIG_DATA }}" ]; then
            echo "ERROR: secret KUBE_CONFIG_DATA not set. Aborting."
            exit 1
          fi
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 --decode > "${KUBECONFIG_FILE}"
          chmod 600 "${KUBECONFIG_FILE}"
          echo "KUBECONFIG=${KUBECONFIG_FILE}" >> $GITHUB_ENV

      - name: Replace images in manifests to point to pushed images
        # This will edit YAML manifests in-place under deploy/kubernetes (and similar) to same tag
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          DOCKER_NAMESPACE: ${{ env.DOCKER_NAMESPACE }}
        run: |
          set -euo pipefail
          ROOTS="deploy/kubernetes deploy/kubernetes/manifests deploy/kubernetes/manifests-*"
          # Define fallback list of services (same as build step)
          SERVICES="front-end edge-router catalogue carts orders shipping queue-master payment user user-sim graphs healthcheck openapi"
          for d in $ROOTS; do
            if [ -d "$d" ]; then
              echo "Scanning $d for YAML files..."
              find "$d" -type f -name '*.y*ml' -print0 | while IFS= read -r -d '' f; do
                for svc in $SERVICES; do
                  # Replace weaveworksdemos/<svc>:* or weaveworks/<svc>:*
                  sed -i -E "s|(weaveworksdemos|weaveworks)/${svc}:[0-9A-Za-z._-]*|${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/${svc}:${IMAGE_TAG}|g" "$f" || true
                done
                # Also replace any image: weaveworksdemos/<something>
                sed -i -E "s|weaveworksdemos/([a-zA-Z0-9_.-]+):[0-9A-Za-z._-]*|${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/\\1:${IMAGE_TAG}|g" "$f" || true
              done
            fi
          done
          echo "Image references updated to tag ${IMAGE_TAG}"

      - name: Apply Kubernetes manifests (deploy)
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}
        run: |
          set -euo pipefail
          # Apply namespaced manifests or the complete-demo
          if [ -f deploy/kubernetes/complete-demo.yaml ]; then
            kubectl apply -f deploy/kubernetes/complete-demo.yaml
          else
            # Apply all manifests under deploy/kubernetes and its subdirs
            find deploy/kubernetes -type f -name '*.y*ml' -print0 | xargs -0 -r kubectl apply -f
          fi

      - name: Wait for deployments to become ready
        run: |
          # Wait up to 10 minutes for all Deployments in the default namespace to be ready (adjust namespace if manifests use a different one)
          timeout=600
          interval=8
          elapsed=0
          echo "Waiting for deployments to become ready..."
          while [ $elapsed -lt $timeout ]; do
            NOT_READY=$(kubectl get deployments --no-headers 2>/dev/null | awk '{if($2!=$3) print $1}')
            if [ -z "$NOT_READY" ]; then
              echo "All deployments ready."
              exit 0
            fi
            echo "Still waiting on: $NOT_READY"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Timed out waiting for deployments to become ready."
          kubectl get deployments
          exit 1
