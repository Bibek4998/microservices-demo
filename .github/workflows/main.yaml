name: CI/CD — Build & Push Microservices, Deploy to Minikube/EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  DOCKER_REGISTRY: docker.io
  IMAGE_TAG: ${{ github.sha }}
  # set default deploy target; override via secrets if needed
  DEPLOY_TARGET: ${{ secrets.DEPLOY_TARGET }}

# List of services to build: "name:context:dockerfile"
# Adjust this list to match the directories and Dockerfile names in your repo.
# I've included the common Sock Shop microservices — edit as needed.
services-to-build:
  - front-end:front-end:Dockerfile
  - catalogue:catalogue:Dockerfile
  - carts:carts:Dockerfile
  - orders:orders:Dockerfile
  - user:user:Dockerfile
  - payment:payment:Dockerfile
  - graphs:graphs:Dockerfile
  - healthcheck:healthcheck:Dockerfile
  - openapi:openapi:Dockerfile

jobs:
  build:
    name: Build & Push Docker images
    runs-on: ubuntu-latest
    # Using a dynamic matrix from the YAML list above
    strategy:
      matrix:
        service: ${{ fromJson('["front-end:front-end:Dockerfile","catalogue:catalogue:Dockerfile","carts:carts:Dockerfile","orders:orders:Dockerfile","user:user:Dockerfile","payment:payment:Dockerfile","graphs:graphs:Dockerfile","healthcheck:healthcheck:Dockerfile","openapi:openapi:Dockerfile"]') }}
      max-parallel: 4
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push image
        id: build-image
        uses: docker/build-push-action@v4
        with:
          context: ${{ github.workspace }}/${{ fromJson('["placeholder"]') }} # placeholder, replaced in run step below
          # we will compute image names in the run wrapper
          push: true
          platforms: linux/amd64
          # use cache to speed up repeated builds (inline cache)
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/build-cache:latest || true
          cache-to: type=inline

      - name: Build & Push (scripted) — proper per-matrix run
        if: always()
        run: |
          IFS=':' read -r name context dockerfile <<< "${{ matrix.service }}"
          echo "Service: $name, context: $context, dockerfile: $dockerfile"
          DOCKER_NAMESPACE="${{ secrets.DOCKER_USERNAME }}"
          IMAGE="${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${name}:${IMAGE_TAG}"
          IMAGE_LATEST="${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/${name}:latest"
          CONTEXT_PATH="${GITHUB_WORKSPACE}/${context}"
          DOCKERFILE_PATH="${CONTEXT_PATH}/${dockerfile}"
          echo "Building ${IMAGE}"
          docker buildx build \
            --platform linux/amd64 \
            -t "${IMAGE}" \
            -t "${IMAGE_LATEST}" \
            -f "${DOCKERFILE_PATH}" \
            "${CONTEXT_PATH}" \
            --push \
            --cache-from=type=registry,ref=${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/build-cache:latest || true
          # update build-cache tag (best-effort)
          docker buildx imagetools create --tag ${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/build-cache:latest ${IMAGE} || true
        shell: bash

  deploy:
    name: Deploy to target (Minikube or EKS)
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 60
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Deploy to Minikube (if DEPLOY_TARGET == minikube)
        if: secrets.DEPLOY_TARGET == 'minikube' || env.DEPLOY_TARGET == 'minikube'
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          # start minikube with resources suitable for Sock Shop
          minikube start --driver=docker --memory=4000m --cpus=4 --disk-size=20g --wait=all
          minikube status
          kubectl apply -f deploy/kubernetes/complete-demo.yaml
          # wait for core pods (adjust labels/names if different)
          NAMESPACE="sock-shop"
          kubectl wait --for=condition=Ready pod -l name=front-end -n $NAMESPACE --timeout=600s || echo "front-end not ready"
          kubectl get pods -n $NAMESPACE -o wide
          FRONTEND_URL=$(minikube service front-end -n $NAMESPACE --url 2>/dev/null | head -n1 || echo "")
          echo "FRONTEND_URL=$FRONTEND_URL"
      
      - name: Configure AWS credentials (OIDC if provided)
        if: secrets.DEPLOY_TARGET == 'eks' || env.DEPLOY_TARGET == 'eks'
        uses: aws-actions/configure-aws-credentials@v2
        with:
          # prefer role-based OIDC if you set AWS_ROLE_TO_ASSUME
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME || '' }}
          aws-region: ${{ secrets.AWS_REGION || env.AWS_REGION || 'us-east-1' }}
          # If role-to-assume is empty, the action will fall back to access keys (if set)
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID || '' }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY || '' }}

      - name: Update kubeconfig for EKS and deploy (if DEPLOY_TARGET == eks)
        if: secrets.DEPLOY_TARGET == 'eks' || env.DEPLOY_TARGET == 'eks'
        env:
          CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME || env.EKS_CLUSTER_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION || env.AWS_REGION || 'ap-south-1' }}
        run: |
          if [ -z "$CLUSTER_NAME" ]; then
            echo "EKS_CLUSTER_NAME must be set in secrets as EKS_CLUSTER_NAME"
            exit 1
          fi
          # Install awscli if missing
          if ! command -v aws >/dev/null 2>&1; then
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
          fi
          aws eks update-kubeconfig --region $AWS_REGION --name $CLUSTER_NAME
          kubectl get nodes -o wide
          # apply manifests (consider templating with kustomize/helm later)
          kubectl apply -f deploy/kubernetes/complete-demo.yaml
          NAMESPACE="sock-shop"
          kubectl wait --for=condition=Available deployment/front-end -n $NAMESPACE --timeout=600s || echo "front-end not available"
          kubectl get pods -n $NAMESPACE -o wide
          kubectl get svc -n $NAMESPACE -o wide

      - name: Final report
        run: |
          echo "=== all done. Inspect pods/services ==="
          kubectl get pods -A -o wide || true
          kubectl get svc -A -o wide || true

      - name: Debug if any issues
        if: failure()
        run: |
          echo "=== Debug info ==="
          kubectl get pods -A -o wide || true
          kubectl get events --sort-by=.lastTimestamp -A | tail -n 50 || true